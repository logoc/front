import {
  __commonJS
} from "./chunk-J43GMYXM.js";

// node_modules/ot-json0/lib/bootstrapTransform.js
var require_bootstrapTransform = __commonJS({
  "node_modules/ot-json0/lib/bootstrapTransform.js"(exports, module) {
    module.exports = bootstrapTransform;
    function bootstrapTransform(type, transformComponent, checkValidOp, append) {
      var transformComponentX = function(left, right, destLeft, destRight) {
        transformComponent(destLeft, left, right, "left");
        transformComponent(destRight, right, left, "right");
      };
      var transformX = type.transformX = function(leftOp, rightOp) {
        checkValidOp(leftOp);
        checkValidOp(rightOp);
        var newRightOp = [];
        for (var i = 0; i < rightOp.length; i++) {
          var rightComponent = rightOp[i];
          var newLeftOp = [];
          var k = 0;
          while (k < leftOp.length) {
            var nextC = [];
            transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
            k++;
            if (nextC.length === 1) {
              rightComponent = nextC[0];
            } else if (nextC.length === 0) {
              for (var j = k; j < leftOp.length; j++) {
                append(newLeftOp, leftOp[j]);
              }
              rightComponent = null;
              break;
            } else {
              var pair = transformX(leftOp.slice(k), nextC);
              for (var l = 0; l < pair[0].length; l++) {
                append(newLeftOp, pair[0][l]);
              }
              for (var r = 0; r < pair[1].length; r++) {
                append(newRightOp, pair[1][r]);
              }
              rightComponent = null;
              break;
            }
          }
          if (rightComponent != null) {
            append(newRightOp, rightComponent);
          }
          leftOp = newLeftOp;
        }
        return [leftOp, newRightOp];
      };
      type.transform = function(op, otherOp, type2) {
        if (!(type2 === "left" || type2 === "right"))
          throw new Error("type must be 'left' or 'right'");
        if (otherOp.length === 0)
          return op;
        if (op.length === 1 && otherOp.length === 1)
          return transformComponent([], op[0], otherOp[0], type2);
        if (type2 === "left")
          return transformX(op, otherOp)[0];
        else
          return transformX(otherOp, op)[1];
      };
    }
  }
});

// node_modules/ot-json0/lib/text0.js
var require_text0 = __commonJS({
  "node_modules/ot-json0/lib/text0.js"(exports, module) {
    var text = module.exports = {
      name: "text0",
      uri: "http://sharejs.org/types/textv0",
      create: function(initial) {
        if (initial != null && typeof initial !== "string") {
          throw new Error("Initial data must be a string");
        }
        return initial || "";
      }
    };
    var strInject = function(s1, pos, s2) {
      return s1.slice(0, pos) + s2 + s1.slice(pos);
    };
    var checkValidComponent = function(c) {
      if (typeof c.p !== "number")
        throw new Error("component missing position field");
      if (typeof c.i === "string" === (typeof c.d === "string"))
        throw new Error("component needs an i or d field");
      if (c.p < 0)
        throw new Error("position cannot be negative");
    };
    var checkValidOp = function(op) {
      for (var i = 0; i < op.length; i++) {
        checkValidComponent(op[i]);
      }
    };
    text.apply = function(snapshot, op) {
      var deleted;
      checkValidOp(op);
      for (var i = 0; i < op.length; i++) {
        var component = op[i];
        if (component.i != null) {
          snapshot = strInject(snapshot, component.p, component.i);
        } else {
          deleted = snapshot.slice(component.p, component.p + component.d.length);
          if (component.d !== deleted)
            throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");
          snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
        }
      }
      return snapshot;
    };
    var append = text._append = function(newOp, c) {
      if (c.i === "" || c.d === "")
        return;
      if (newOp.length === 0) {
        newOp.push(c);
      } else {
        var last = newOp[newOp.length - 1];
        if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {
          newOp[newOp.length - 1] = { i: strInject(last.i, c.p - last.p, c.i), p: last.p };
        } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {
          newOp[newOp.length - 1] = { d: strInject(c.d, last.p - c.p, last.d), p: c.p };
        } else {
          newOp.push(c);
        }
      }
    };
    text.compose = function(op1, op2) {
      checkValidOp(op1);
      checkValidOp(op2);
      var newOp = op1.slice();
      for (var i = 0; i < op2.length; i++) {
        append(newOp, op2[i]);
      }
      return newOp;
    };
    text.normalize = function(op) {
      var newOp = [];
      if (op.i != null || op.p != null)
        op = [op];
      for (var i = 0; i < op.length; i++) {
        var c = op[i];
        if (c.p == null)
          c.p = 0;
        append(newOp, c);
      }
      return newOp;
    };
    var transformPosition = function(pos, c, insertAfter) {
      if (c.i != null) {
        if (c.p < pos || c.p === pos && insertAfter) {
          return pos + c.i.length;
        } else {
          return pos;
        }
      } else {
        if (pos <= c.p) {
          return pos;
        } else if (pos <= c.p + c.d.length) {
          return c.p;
        } else {
          return pos - c.d.length;
        }
      }
    };
    text.transformCursor = function(position, op, side) {
      var insertAfter = side === "right";
      for (var i = 0; i < op.length; i++) {
        position = transformPosition(position, op[i], insertAfter);
      }
      return position;
    };
    var transformComponent = text._tc = function(dest, c, otherC, side) {
      checkValidComponent(c);
      checkValidComponent(otherC);
      if (c.i != null) {
        append(dest, { i: c.i, p: transformPosition(c.p, otherC, side === "right") });
      } else {
        if (otherC.i != null) {
          var s = c.d;
          if (c.p < otherC.p) {
            append(dest, { d: s.slice(0, otherC.p - c.p), p: c.p });
            s = s.slice(otherC.p - c.p);
          }
          if (s !== "")
            append(dest, { d: s, p: c.p + otherC.i.length });
        } else {
          if (c.p >= otherC.p + otherC.d.length)
            append(dest, { d: c.d, p: c.p - otherC.d.length });
          else if (c.p + c.d.length <= otherC.p)
            append(dest, c);
          else {
            var newC = { d: "", p: c.p };
            if (c.p < otherC.p)
              newC.d = c.d.slice(0, otherC.p - c.p);
            if (c.p + c.d.length > otherC.p + otherC.d.length)
              newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);
            var intersectStart = Math.max(c.p, otherC.p);
            var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
            var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
            var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
            if (cIntersect !== otherIntersect)
              throw new Error("Delete ops delete different text in the same region of the document");
            if (newC.d !== "") {
              newC.p = transformPosition(newC.p, otherC);
              append(dest, newC);
            }
          }
        }
      }
      return dest;
    };
    var invertComponent = function(c) {
      return c.i != null ? { d: c.i, p: c.p } : { i: c.d, p: c.p };
    };
    text.invert = function(op) {
      op = op.slice().reverse();
      for (var i = 0; i < op.length; i++) {
        op[i] = invertComponent(op[i]);
      }
      return op;
    };
    require_bootstrapTransform()(text, transformComponent, checkValidOp, append);
  }
});

// node_modules/ot-json0/lib/json0.js
var require_json0 = __commonJS({
  "node_modules/ot-json0/lib/json0.js"(exports, module) {
    var isArray = function(obj) {
      return Object.prototype.toString.call(obj) == "[object Array]";
    };
    var isObject = function(obj) {
      return !!obj && obj.constructor === Object;
    };
    var clone = function(o) {
      return JSON.parse(JSON.stringify(o));
    };
    var json = {
      name: "json0",
      uri: "http://sharejs.org/types/JSONv0"
    };
    var subtypes = {};
    json.registerSubtype = function(subtype) {
      subtypes[subtype.name] = subtype;
    };
    json.create = function(data) {
      return data === void 0 ? null : clone(data);
    };
    json.invertComponent = function(c) {
      var c_ = { p: c.p };
      if (c.t && subtypes[c.t]) {
        c_.t = c.t;
        c_.o = subtypes[c.t].invert(c.o);
      }
      if (c.si !== void 0)
        c_.sd = c.si;
      if (c.sd !== void 0)
        c_.si = c.sd;
      if (c.oi !== void 0)
        c_.od = c.oi;
      if (c.od !== void 0)
        c_.oi = c.od;
      if (c.li !== void 0)
        c_.ld = c.li;
      if (c.ld !== void 0)
        c_.li = c.ld;
      if (c.na !== void 0)
        c_.na = -c.na;
      if (c.lm !== void 0) {
        c_.lm = c.p[c.p.length - 1];
        c_.p = c.p.slice(0, c.p.length - 1).concat([c.lm]);
      }
      return c_;
    };
    json.invert = function(op) {
      var op_ = op.slice().reverse();
      var iop = [];
      for (var i = 0; i < op_.length; i++) {
        iop.push(json.invertComponent(op_[i]));
      }
      return iop;
    };
    json.checkValidOp = function(op) {
      for (var i = 0; i < op.length; i++) {
        if (!isArray(op[i].p))
          throw new Error("Missing path");
      }
    };
    json.checkList = function(elem) {
      if (!isArray(elem))
        throw new Error("Referenced element not a list");
    };
    json.checkObj = function(elem) {
      if (!isObject(elem)) {
        throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
      }
    };
    function convertFromText(c) {
      c.t = "text0";
      var o = { p: c.p.pop() };
      if (c.si != null)
        o.i = c.si;
      if (c.sd != null)
        o.d = c.sd;
      c.o = [o];
    }
    function convertToText(c) {
      c.p.push(c.o[0].p);
      if (c.o[0].i != null)
        c.si = c.o[0].i;
      if (c.o[0].d != null)
        c.sd = c.o[0].d;
      delete c.t;
      delete c.o;
    }
    json.apply = function(snapshot, op) {
      json.checkValidOp(op);
      op = clone(op);
      var container = {
        data: snapshot
      };
      for (var i = 0; i < op.length; i++) {
        var c = op[i];
        if (c.si != null || c.sd != null)
          convertFromText(c);
        var parent = null;
        var parentKey = null;
        var elem = container;
        var key = "data";
        for (var j = 0; j < c.p.length; j++) {
          var p = c.p[j];
          parent = elem;
          parentKey = key;
          elem = elem[key];
          key = p;
          if (parent == null)
            throw new Error("Path invalid");
        }
        if (c.t && c.o !== void 0 && subtypes[c.t]) {
          elem[key] = subtypes[c.t].apply(elem[key], c.o);
        } else if (c.na !== void 0) {
          if (typeof elem[key] != "number")
            throw new Error("Referenced element not a number");
          elem[key] += c.na;
        } else if (c.li !== void 0 && c.ld !== void 0) {
          json.checkList(elem);
          elem[key] = c.li;
        } else if (c.li !== void 0) {
          json.checkList(elem);
          elem.splice(key, 0, c.li);
        } else if (c.ld !== void 0) {
          json.checkList(elem);
          elem.splice(key, 1);
        } else if (c.lm !== void 0) {
          json.checkList(elem);
          if (c.lm != key) {
            var e = elem[key];
            elem.splice(key, 1);
            elem.splice(c.lm, 0, e);
          }
        } else if (c.oi !== void 0) {
          json.checkObj(elem);
          elem[key] = c.oi;
        } else if (c.od !== void 0) {
          json.checkObj(elem);
          delete elem[key];
        } else {
          throw new Error("invalid / missing instruction in op");
        }
      }
      return container.data;
    };
    json.shatter = function(op) {
      var results = [];
      for (var i = 0; i < op.length; i++) {
        results.push([op[i]]);
      }
      return results;
    };
    json.incrementalApply = function(snapshot, op, _yield) {
      for (var i = 0; i < op.length; i++) {
        var smallOp = [op[i]];
        snapshot = json.apply(snapshot, smallOp);
        _yield(smallOp, snapshot);
      }
      return snapshot;
    };
    var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
      if (p1.length != p2.length)
        return false;
      for (var i = 0; i < p1.length; i++) {
        if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
          return false;
      }
      return true;
    };
    json.append = function(dest, c) {
      c = clone(c);
      if (dest.length === 0) {
        dest.push(c);
        return;
      }
      var last = dest[dest.length - 1];
      if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
        convertFromText(c);
        convertFromText(last);
      }
      if (pathMatches(c.p, last.p)) {
        if (c.t && last.t && c.t === last.t && subtypes[c.t]) {
          last.o = subtypes[c.t].compose(last.o, c.o);
          if (c.si != null || c.sd != null) {
            var p = c.p;
            for (var i = 0; i < last.o.length - 1; i++) {
              c.o = [last.o.pop()];
              c.p = p.slice();
              convertToText(c);
              dest.push(c);
            }
            convertToText(last);
          }
        } else if (last.na != null && c.na != null) {
          dest[dest.length - 1] = { p: last.p, na: last.na + c.na };
        } else if (last.li !== void 0 && c.li === void 0 && c.ld === last.li) {
          if (last.ld !== void 0) {
            delete last.li;
          } else {
            dest.pop();
          }
        } else if (last.od !== void 0 && last.oi === void 0 && c.oi !== void 0 && c.od === void 0) {
          last.oi = c.oi;
        } else if (last.oi !== void 0 && c.od !== void 0) {
          if (c.oi !== void 0) {
            last.oi = c.oi;
          } else if (last.od !== void 0) {
            delete last.oi;
          } else {
            dest.pop();
          }
        } else if (c.lm !== void 0 && c.p[c.p.length - 1] === c.lm) {
        } else {
          dest.push(c);
        }
      } else {
        if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
          convertToText(c);
          convertToText(last);
        }
        dest.push(c);
      }
    };
    json.compose = function(op1, op2) {
      json.checkValidOp(op1);
      json.checkValidOp(op2);
      var newOp = clone(op1);
      for (var i = 0; i < op2.length; i++) {
        json.append(newOp, op2[i]);
      }
      return newOp;
    };
    json.normalize = function(op) {
      var newOp = [];
      op = isArray(op) ? op : [op];
      for (var i = 0; i < op.length; i++) {
        var c = op[i];
        if (c.p == null)
          c.p = [];
        json.append(newOp, c);
      }
      return newOp;
    };
    json.commonLengthForOps = function(a, b) {
      var alen = a.p.length;
      var blen = b.p.length;
      if (a.na != null || a.t)
        alen++;
      if (b.na != null || b.t)
        blen++;
      if (alen === 0)
        return -1;
      if (blen === 0)
        return null;
      alen--;
      blen--;
      for (var i = 0; i < alen; i++) {
        var p = a.p[i];
        if (i >= blen || p !== b.p[i])
          return null;
      }
      return alen;
    };
    json.canOpAffectPath = function(op, path) {
      return json.commonLengthForOps({ p: path }, op) != null;
    };
    json.transformComponent = function(dest, c, otherC, type) {
      c = clone(c);
      var common = json.commonLengthForOps(otherC, c);
      var common2 = json.commonLengthForOps(c, otherC);
      var cplength = c.p.length;
      var otherCplength = otherC.p.length;
      if (c.na != null || c.t)
        cplength++;
      if (otherC.na != null || otherC.t)
        otherCplength++;
      if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
        if (c.ld !== void 0) {
          var oc = clone(otherC);
          oc.p = oc.p.slice(cplength);
          c.ld = json.apply(clone(c.ld), [oc]);
        } else if (c.od !== void 0) {
          var oc = clone(otherC);
          oc.p = oc.p.slice(cplength);
          c.od = json.apply(clone(c.od), [oc]);
        }
      }
      if (common != null) {
        var commonOperand = cplength == otherCplength;
        var oc = otherC;
        if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {
          convertFromText(c);
          oc = clone(otherC);
          convertFromText(oc);
        }
        if (oc.t && subtypes[oc.t]) {
          if (c.t && c.t === oc.t) {
            var res = subtypes[c.t].transform(c.o, oc.o, type);
            if (c.si != null || c.sd != null) {
              var p = c.p;
              for (var i = 0; i < res.length; i++) {
                c.o = [res[i]];
                c.p = p.slice();
                convertToText(c);
                json.append(dest, c);
              }
            } else if (!isArray(res) || res.length > 0) {
              c.o = res;
              json.append(dest, c);
            }
            return dest;
          }
        } else if (otherC.na !== void 0) {
        } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
          if (otherC.p[common] === c.p[common]) {
            if (!commonOperand) {
              return dest;
            } else if (c.ld !== void 0) {
              if (c.li !== void 0 && type === "left") {
                c.ld = clone(otherC.li);
              } else {
                return dest;
              }
            }
          }
        } else if (otherC.li !== void 0) {
          if (c.li !== void 0 && c.ld === void 0 && commonOperand && c.p[common] === otherC.p[common]) {
            if (type === "right")
              c.p[common]++;
          } else if (otherC.p[common] <= c.p[common]) {
            c.p[common]++;
          }
          if (c.lm !== void 0) {
            if (commonOperand) {
              if (otherC.p[common] <= c.lm)
                c.lm++;
            }
          }
        } else if (otherC.ld !== void 0) {
          if (c.lm !== void 0) {
            if (commonOperand) {
              if (otherC.p[common] === c.p[common]) {
                return dest;
              }
              var p = otherC.p[common];
              var from = c.p[common];
              var to = c.lm;
              if (p < to || p === to && from < to)
                c.lm--;
            }
          }
          if (otherC.p[common] < c.p[common]) {
            c.p[common]--;
          } else if (otherC.p[common] === c.p[common]) {
            if (otherCplength < cplength) {
              return dest;
            } else if (c.ld !== void 0) {
              if (c.li !== void 0) {
                delete c.ld;
              } else {
                return dest;
              }
            }
          }
        } else if (otherC.lm !== void 0) {
          if (c.lm !== void 0 && cplength === otherCplength) {
            var from = c.p[common];
            var to = c.lm;
            var otherFrom = otherC.p[common];
            var otherTo = otherC.lm;
            if (otherFrom !== otherTo) {
              if (from === otherFrom) {
                if (type === "left") {
                  c.p[common] = otherTo;
                  if (from === to)
                    c.lm = otherTo;
                } else {
                  return dest;
                }
              } else {
                if (from > otherFrom)
                  c.p[common]--;
                if (from > otherTo)
                  c.p[common]++;
                else if (from === otherTo) {
                  if (otherFrom > otherTo) {
                    c.p[common]++;
                    if (from === to)
                      c.lm++;
                  }
                }
                if (to > otherFrom) {
                  c.lm--;
                } else if (to === otherFrom) {
                  if (to > from)
                    c.lm--;
                }
                if (to > otherTo) {
                  c.lm++;
                } else if (to === otherTo) {
                  if (otherTo > otherFrom && to > from || otherTo < otherFrom && to < from) {
                    if (type === "right")
                      c.lm++;
                  } else {
                    if (to > from)
                      c.lm++;
                    else if (to === otherFrom)
                      c.lm--;
                  }
                }
              }
            }
          } else if (c.li !== void 0 && c.ld === void 0 && commonOperand) {
            var from = otherC.p[common];
            var to = otherC.lm;
            p = c.p[common];
            if (p > from)
              c.p[common]--;
            if (p > to)
              c.p[common]++;
          } else {
            var from = otherC.p[common];
            var to = otherC.lm;
            p = c.p[common];
            if (p === from) {
              c.p[common] = to;
            } else {
              if (p > from)
                c.p[common]--;
              if (p > to)
                c.p[common]++;
              else if (p === to && from > to)
                c.p[common]++;
            }
          }
        } else if (otherC.oi !== void 0 && otherC.od !== void 0) {
          if (c.p[common] === otherC.p[common]) {
            if (c.oi !== void 0 && commonOperand) {
              if (type === "right") {
                return dest;
              } else {
                c.od = otherC.oi;
              }
            } else {
              return dest;
            }
          }
        } else if (otherC.oi !== void 0) {
          if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
            if (type === "left") {
              json.append(dest, { p: c.p, od: otherC.oi });
            } else {
              return dest;
            }
          }
        } else if (otherC.od !== void 0) {
          if (c.p[common] == otherC.p[common]) {
            if (!commonOperand)
              return dest;
            if (c.oi !== void 0) {
              delete c.od;
            } else {
              return dest;
            }
          }
        }
      }
      json.append(dest, c);
      return dest;
    };
    require_bootstrapTransform()(json, json.transformComponent, json.checkValidOp, json.append);
    var text = require_text0();
    json.registerSubtype(text);
    module.exports = json;
  }
});

// node_modules/ot-json0/lib/index.js
var require_lib = __commonJS({
  "node_modules/ot-json0/lib/index.js"(exports, module) {
    module.exports = {
      type: require_json0()
    };
  }
});
export default require_lib();
//# sourceMappingURL=ot-json0.js.map
